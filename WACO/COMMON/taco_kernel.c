#include <stdint.h> 
typedef enum { COMPRESSED, UNCOMPRESSED } taco_mode_t;
typedef struct {
  int32_t      order;
  int32_t*     dimensions;
  int32_t      csize;
  int32_t*     mode_ordering;
  taco_mode_t* mode_types;
  uint8_t***   indices;
  uint8_t*     vals;
  int32_t      vals_size;
} taco_tensor_t;
// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// /home/chamika2/waco-extend/code_generator/taco/build/bin/taco "C(i,j1,j0)=A(i,j1,j0)*B(i,k1,k0)*D(j1,j0,k1,k0)" -f=C:ssd:0,1,2 -f=A:ssd:0,1,2 -f=B:ddd:0,1,2 -f=D:dddd:0,1,2,3 -t=C:float -t=A:float -t=B:float -t=D:float -write-compute=taco_kernel.c -s="bound(j0,j0b,2, MaxExact)" -s="bound(k0,k0b,64, MaxExact)" -s="bound(k1,k1b,4, MaxExact)" -s="reorder(i,j1,k1b,j0b,k0b)" -s="parallelize(i,CPUThread,NoRaces)"

int compute(taco_tensor_t *C, taco_tensor_t *A, taco_tensor_t *B, taco_tensor_t *D, taco_tensor_t *Cd, taco_tensor_t *Ad, taco_tensor_t *Bd, taco_tensor_t *Dd) {
  int C3_dimension = (int)(C->dimensions[2]);
  float* __restrict C_vals = (float*)(C->vals);
  int A3_dimension = (int)(A->dimensions[2]);
  int* __restrict A1_pos = (int*)(A->indices[0][0]);
  int* __restrict A1_crd = (int*)(A->indices[0][1]);
  int* __restrict A2_pos = (int*)(A->indices[1][0]);
  int* __restrict A2_crd = (int*)(A->indices[1][1]);
  float* __restrict A_vals = (float*)(A->vals);
  int B1_dimension = (int)(B->dimensions[0]);
  int B2_dimension = (int)(B->dimensions[1]);
  int B3_dimension = (int)(B->dimensions[2]);
  float* __restrict B_vals = (float*)(B->vals);
  int D1_dimension = (int)(D->dimensions[0]);
  int D2_dimension = (int)(D->dimensions[1]);
  int D3_dimension = (int)(D->dimensions[2]);
  int D4_dimension = (int)(D->dimensions[3]);
  float* __restrict D_vals = (float*)(D->vals);

  int32_t j1C = 0;

  #pragma omp parallel for schedule(runtime)
  for (int32_t iA = A1_pos[0]; iA < A1_pos[1]; iA++) {
    int32_t i = A1_crd[iA];
    for (int32_t j1A = A2_pos[iA]; j1A < A2_pos[(iA + 1)]; j1A++) {
      int32_t j1 = A2_crd[j1A];
      for (int32_t k1b = 0; k1b < 4; k1b++) {
        int32_t k1B = i * B2_dimension + k1b;
        for (int32_t j0b = 0; j0b < 2; j0b++) {
          int32_t j0A = j1A * A3_dimension + j0b;
          int32_t j0D = j1 * D2_dimension + j0b;
          int32_t k1D = j0D * D3_dimension + k1b;
          int32_t j0C = j1C * C3_dimension + j0b;
          float tk0bC_val = 0.0;
          for (int32_t k0b = 0; k0b < 64; k0b++) {
            int32_t k0B = k1B * B3_dimension + k0b;
            int32_t k0D = k1D * D4_dimension + k0b;
            tk0bC_val += (A_vals[j0A] * B_vals[k0B]) * D_vals[k0D];
          }
          C_vals[j0A] = C_vals[j0A] + tk0bC_val;
        }
      }
      j1C++;
    }
  }
  return 0;
}
